(function(window){let pendingCalls=[];let isSignalRLoaded=false;const queueOrExecute=(fnName,args)=>{if(isSignalRLoaded){return window.Codicent[fnName](...args)}else{return new Promise((resolve,reject)=>{pendingCalls.push({fnName:fnName,args:args,resolve:resolve,reject:reject})})}};window.Codicent={version:"1.0.0",baseUrl:"https://codicent.com/",token:null,signalRHost:"https://pubsub.codicent.com/hub",state:{},log:()=>{},handleMessage:()=>{},init:(...args)=>queueOrExecute("init",args),postMessage:(...args)=>queueOrExecute("postMessage",args),getMessages:(...args)=>queueOrExecute("getMessages",args)};const signalRScript=document.createElement("script");signalRScript.src="https://cdnjs.cloudflare.com/ajax/libs/microsoft-signalr/3.1.0/signalr.js";signalRScript.onload=()=>{initCodicent();isSignalRLoaded=true;pendingCalls.forEach(({fnName,args,resolve,reject})=>{try{const result=window.Codicent[fnName](...args);if(result&&typeof result.then==="function"){result.then(resolve).catch(reject)}else{resolve(result)}}catch(error){reject(error)}});pendingCalls=[]};signalRScript.onerror=()=>{console.warn("SignalR failed to load. Some Codicent features may not be available.");window.Codicent.init=(props={})=>{window.Codicent={...window.Codicent,...props};console.warn("Codicent initialized in fallback mode. Real-time features are not available.")};isSignalRLoaded=true;pendingCalls.forEach(({reject})=>{reject(new Error("SignalR failed to load. Codicent features are not available."))});pendingCalls=[]};document.head.appendChild(signalRScript);const initCodicent=()=>{const robustFetch=async(url,options={},retryOptions={})=>{const{maxRetries=3,baseDelay=1e3,maxDelay=12e4,exponentialBase=2,jitterFactor=.1,retryOn=[408,429,500,502,503,504],timeout=3e4}=retryOptions;const{log}=window.Codicent;for(let attempt=0;attempt<=maxRetries;attempt++){let controller;let timeoutId;try{controller=new AbortController;let signal=controller.signal;if(options.signal){const combinedController=new AbortController;signal=combinedController.signal;if(options.signal.aborted){combinedController.abort()}else{options.signal.addEventListener("abort",()=>{combinedController.abort()},{once:true})}if(controller.signal.aborted){combinedController.abort()}else{controller.signal.addEventListener("abort",()=>{combinedController.abort()},{once:true})}}timeoutId=setTimeout(()=>controller.abort(),timeout);const response=await fetch(url,{...options,signal:signal});clearTimeout(timeoutId);if(!response.ok&&retryOn.includes(response.status)&&attempt<maxRetries){const delay=calculateRetryDelay(attempt,baseDelay,exponentialBase,maxDelay,jitterFactor);log(`HTTP ${response.status} error, retrying in ${delay}ms (attempt ${attempt+1}/${maxRetries})`);await sleep(delay);continue}return response}catch(error){clearTimeout(timeoutId);if(error.name==="AbortError"&&options.signal?.aborted){throw error}if(attempt===maxRetries){throw error}const shouldRetry=error.name==="AbortError"||error.name==="TypeError"||error.name==="NetworkError"||error.message?.includes("fetch");if(shouldRetry){const delay=calculateRetryDelay(attempt,baseDelay,exponentialBase,maxDelay,jitterFactor);log(`Network error: ${error.message}, retrying in ${delay}ms (attempt ${attempt+1}/${maxRetries})`);await sleep(delay);continue}throw error}}};const calculateRetryDelay=(attempt,baseDelay,exponentialBase,maxDelay,jitterFactor)=>{const exponentialDelay=baseDelay*Math.pow(exponentialBase,attempt);const jitter=exponentialDelay*jitterFactor*(Math.random()*2-1);return Math.min(exponentialDelay+jitter,maxDelay)};const sleep=ms=>new Promise(resolve=>setTimeout(resolve,ms));const fullCodicentObject={version:"1.0.0",baseUrl:"https://codicent.com/",token:null,signalRHost:"https://pubsub.codicent.com/hub",state:{},log:()=>{},handleMessage:()=>{},init:(props={})=>{window.Codicent={...window.Codicent,...props};const{token,signalRHost,log,handleMessage}=window.Codicent;if(!token||token.trim()===""){throw new Error("Token is required to initialize Codicent")}if(!signalRHost||signalRHost.trim()===""){throw new Error("SignalR Host is required to initialize Codicent")}window.Codicent.state.connection=(new signalR.HubConnectionBuilder).withUrl(signalRHost,{accessTokenFactory:()=>token}).configureLogging(signalR.LogLevel.None).withAutomaticReconnect().build();const{connection}=window.Codicent.state;let connectionErrorLogged=false;let connectionAttempts=0;const maxConnectionAttempts=props.maxConnectionAttempts||5;let baseRetryDelay=1e4;let reconnectTimeout=null;let isConnecting=false;const startSignalR=async()=>{if(isConnecting){log("Connection attempt already in progress, skipping redundant attempt");return}if(connectionAttempts>=maxConnectionAttempts){log(`Maximum connection attempts (${maxConnectionAttempts}) reached. Stopping reconnection attempts.`);return}try{isConnecting=true;await connection.start();connectionErrorLogged=false;connectionAttempts=0;baseRetryDelay=1e4;log("SignalR connection established successfully.");isConnecting=false}catch(err){connectionAttempts++;const isCorsError=err.message&&(err.message.includes("CORS")||err.message.includes("Failed to fetch")||err.message.includes("NetworkError"));if(!connectionErrorLogged){if(isCorsError){log(`SignalR connection CORS error detected. This may be due to cross-origin restrictions. Attempts: ${connectionAttempts}/${maxConnectionAttempts}`)}else{log(`SignalR connection error: ${err}. Attempts: ${connectionAttempts}/${maxConnectionAttempts}`)}connectionErrorLogged=true}if(reconnectTimeout){clearTimeout(reconnectTimeout)}const exponentialDelay=baseRetryDelay*Math.pow(2,Math.min(connectionAttempts-1,6));const jitter=Math.random()*.3*exponentialDelay;const retryDelay=exponentialDelay+jitter;const cappedDelay=Math.min(retryDelay,12e4);log(`Reconnecting in ${Math.round(cappedDelay/1e3)} seconds (attempt ${connectionAttempts}/${maxConnectionAttempts})`);isConnecting=false;if(connectionAttempts<maxConnectionAttempts){reconnectTimeout=setTimeout(startSignalR,cappedDelay)}}};connection.onclose(async()=>{connectionErrorLogged=false;log("SignalR connection closed. Attempting to reconnect...");if(reconnectTimeout){clearTimeout(reconnectTimeout)}reconnectTimeout=setTimeout(startSignalR,1e3)});startSignalR();connection.on("NewMessage",message=>{log(message);handleMessage(message)});refreshUI()},refresh:()=>refreshUI(),upload:async(formData,filename)=>{const{log,baseUrl,token}=window.Codicent;try{const response=await robustFetch(`${baseUrl}app/UploadFile?filename=${encodeURIComponent(filename)}`,{method:"POST",headers:{Authorization:`Bearer ${token}`},body:formData},{timeout:6e4});if(!response.ok){throw new Error(`HTTP error! status: ${response.status}`)}const id=await response.json();log(`File uploaded successfully. ID: ${id}`);return id}catch(error){log("Error uploading file:",error);throw error}},getFileInfo:async fileId=>{const{log,baseUrl,token}=window.Codicent;try{const response=await robustFetch(`${baseUrl}app/GetFileInfo?fileId=${fileId}`,{method:"GET",headers:{Authorization:`Bearer ${token}`}});if(!response.ok){throw new Error(`HTTP error! status: ${response.status}`)}const fileInfo=await response.json();log(`File info retrieved successfully. ID: ${fileId}`);const{id,filename,createdAt,contentType}=fileInfo;return{id:id,filename:filename,createdAt:new Date(createdAt),contentType:contentType}}catch(error){log("Error getting file info:",error);throw error}},postMessage:async({message,parentId,type})=>{const{token,log,baseUrl}=window.Codicent;if(!message||message.trim()===""){throw new Error("Parameter message is required to post a message")}try{const response=await robustFetch(`${baseUrl}app/AddChatMessage`,{method:"POST",headers:[["Content-Type","application/json; charset=utf-8"],["Authorization",`Bearer ${token}`]],body:JSON.stringify({id:undefined,content:message,type:type||"info",nickname:undefined,createdAt:new Date,isNew:false,parentId:parentId||undefined})});if(!response.ok){throw new Error(`HTTP error: ${response.status}`)}const result=await response.json();return result.id}catch(error){log(`Error posting message: ${error.message}`);throw error}},getMessages:async(props={})=>{const{token,log,baseUrl}=window.Codicent;const{start,length,search,afterTimestamp,beforeTimestamp}={...{start:0,length:10,search:""},...props};try{const response=await robustFetch(`${baseUrl}app/GetChatMessages?start=${start}&length=${length}&search=${encodeURIComponent(search)}${afterTimestamp?`&afterTimestamp=${afterTimestamp.toISOString()}`:""}${beforeTimestamp?`&beforeTimestamp=${beforeTimestamp.toISOString()}`:""}${props.skipContent!==true?"&includeContent=true":""}`,{method:"GET",headers:[["Content-Type","application/json; charset=utf-8"],["Authorization",`Bearer ${token}`]]});if(!response.ok){throw new Error(`HTTP error: ${response.status}`)}let messages=await response.json();messages.forEach(m=>{m.createdAt=new Date(Date.parse(m.createdAt))});return messages}catch(error){log(`Error getting messages: ${error.message}`);throw error}},getDataMessages:async({codicent,tags,search,start,length,dataFilters})=>{const{token,log,baseUrl}=window.Codicent;try{const response=await robustFetch(`${baseUrl}app/FindDataMessages?project=${codicent}${search?"&search="+encodeURIComponent(search):""}${start?"&start="+start:""}${length?"&length="+length:""}`,{method:"POST",headers:[["Content-Type","application/json; charset=utf-8"],["Authorization",`Bearer ${token}`]],body:JSON.stringify({tags:tags,dataFilters:dataFilters||undefined})});if(!response.ok){throw new Error(`HTTP error: ${response.status}`)}const data=await response.json();return data}catch(error){log(`Error getting data messages: ${error.message}`);throw error}},getChatReply:async message=>{const{token,log,baseUrl}=window.Codicent;const controller=new AbortController;const signal=controller.signal;try{const response=await robustFetch(`${baseUrl}api/GetChatReply2?message=${encodeURIComponent(message)}`,{method:"GET",headers:[["Authorization",`Bearer ${token}`]],signal:signal},{maxRetries:1,timeout:5*6e4});if(!response.ok){throw new Error(`HTTP error: ${response.status}`)}const reply=await response.text();return reply}catch(error){log(`Error getting chat reply: ${error.message}`);throw error}},getChatReply2:async({message,codicent,messageId})=>{const{token,log,baseUrl}=window.Codicent;const controller=new AbortController;const signal=controller.signal;try{const response=await robustFetch(`${baseUrl}app/GetAi2ChatReply?message=${encodeURIComponent(message)}&project=${codicent}${messageId?`&messageId=${messageId}`:""}`,{method:"GET",headers:[["Authorization",`Bearer ${token}`]],signal:signal},{maxRetries:1,timeout:5*6e4});if(!response.ok){throw new Error(`HTTP error: ${response.status}`)}const reply=await response.json();return{id:reply.id,content:reply.content.substring(codicent.length+2)}}catch(error){log(`Error getting chat reply: ${error.message}`);throw error}},getChatReply3:async({message,codicent,messageId})=>{const{token,log,baseUrl}=window.Codicent;const controller=new AbortController;const signal=controller.signal;try{const response=await robustFetch(`${baseUrl}app/GetAi2ChatReply`,{method:"POST",headers:{"Content-Type":"application/json; charset=utf-8",Authorization:`Bearer ${token}`},body:JSON.stringify({message:message,project:codicent,messageId:messageId}),signal:signal},{maxRetries:1,timeout:5*6e4});if(!response.ok){throw new Error(`HTTP error: ${response.status}`)}const reply=await response.json();return{id:reply.id,content:reply.content.substring(codicent.length+2)}}catch(error){log(`Error getting chat reply: ${error.message}`);throw error}},getChatReply4:async({message,codicent,messageId,maxPollingTime=5*60*1e3,pollingInterval=2e3})=>{const{token,log,baseUrl}=window.Codicent;const startPayload={project:codicent,message:message};if(messageId){startPayload.messageId=messageId}let promptMessageId;try{const startResponse=await robustFetch(`${baseUrl}app/StartAi2ChatAsync`,{method:"POST",headers:[["Content-Type","application/json; charset=utf-8"],["Authorization",`Bearer ${token}`]],body:JSON.stringify(startPayload)});if(!startResponse.ok){if(startResponse.status===401){}log(`Failed to start AI chat: ${startResponse.status}`);return undefined}const startJson=await startResponse.json();promptMessageId=startJson.promptMessageId;if(!promptMessageId){log("No promptMessageId returned from server");return undefined}}catch(error){log("Error starting AI chat:",error);return undefined}const startTime=Date.now();while(Date.now()-startTime<maxPollingTime){try{const statusResponse=await robustFetch(`${baseUrl}app/GetAi2ChatReplyStatus?promptMessageId=${promptMessageId}`,{method:"GET",headers:[["Authorization",`Bearer ${token}`]]});if(statusResponse.status===202){await new Promise(resolve=>setTimeout(resolve,pollingInterval));continue}if(!statusResponse.ok){log(`Error polling AI chat status: ${statusResponse.status}`);return undefined}const json=await statusResponse.json();const reply=json;return{id:reply.id,content:reply.content.substring(codicent.length+2)}}catch(error){log("Error polling AI chat status:",error);return undefined}}log("Polling timeout reached for AI chat");return undefined},data:{create:async({codicent,tag,data})=>{if(!codicent)throw new Error("codicent is required");const tagString=`#${tag}`;const mention=`@${codicent}`;const message=`${mention} #data ${tagString} ${JSON.stringify(data)}`;return window.Codicent.postMessage({message:message})},read:async({codicent,tag,search=undefined,start=undefined,length=undefined,dataFilters=undefined})=>{const params={codicent:codicent,tags:[tag],search:search,start:start,length:length,dataFilters:dataFilters};return window.Codicent.getDataMessages(params)},readOne:async id=>{const messages=await window.Codicent.getMessages({search:id,length:1});return messages.length?messages[0]:null},update:async({id,data,codicent})=>{if(!codicent)throw new Error("codicent is required");const oldMessages=await window.Codicent.getMessages({search:id,length:1});if(!oldMessages.length)throw new Error("Old message not found");const oldMsg=oldMessages[0];const tagMatch=getTags(oldMsg.content);if(!tagMatch.length)throw new Error("No tags found in old message");const tagString=tagMatch.join(" ").trim();const mention=`@${codicent}`;const message=`${mention} ${tagString} ${JSON.stringify(data)}`;return window.Codicent.postMessage({message:message,parentId:id})},delete:async({id,codicent})=>{return window.Codicent.postMessage({message:`@${codicent} #hidden`,parentId:id})}},createCustomElement:createCustomElement=(elementName,template)=>{class CustomElement extends HTMLElement{constructor(){super();this.attachShadow({mode:"open"})}static get observedAttributes(){const regex=/{{(.*?)}}/g;const matches=[...template.matchAll(regex)];return matches.map(match=>match[1])}attributeChangedCallback(name,oldValue,newValue){this.render()}connectedCallback(){this.render()}render(){let renderedTemplate=template;const dataAttr=this.getAttribute("data");if(dataAttr){const data=JSON.parse(dataAttr);const collectionRegex=/{{#each}}([\s\S]*?){{\/each}}/g;renderedTemplate=renderedTemplate.replace(collectionRegex,(match,p1)=>{return data.map(item=>{let itemTemplate=p1;Object.keys(item).forEach(key=>{const itemRegex=new RegExp(`{{${key}}}`,"g");itemTemplate=itemTemplate.replace(itemRegex,item[key])});return itemTemplate}).join("")})}CustomElement.observedAttributes.forEach(attr=>{const value=this.getAttribute(attr)||"";const regex=new RegExp(`{{${attr}}}`,"g");renderedTemplate=renderedTemplate.replace(regex,value)});this.shadowRoot.innerHTML=renderedTemplate}}customElements.define(elementName,CustomElement)}};window.Codicent={...window.Codicent,...fullCodicentObject};const isData=message=>{if(!message)return false;const start=message.indexOf("{");const end=message.lastIndexOf("}");if(start!==-1&&end!==-1){const data=message.substring(start,end+1);try{JSON.parse(data);return true}catch{return false}}return false};const getContentWithoutData=message=>{if(isData(message)){const start=message.indexOf("{");const end=message.lastIndexOf("}");const content=message.substring(0,start)+message.substring(end+1);return content}return message};const getMentions=text=>{const matches=getContentWithoutData(text).match(/(\s|^)@[a-zA-Z0-9_-]+/g);if(!matches){return[]}return matches.map(m=>m.trim())};const getTags=text=>{if(!text){return[]}const matches=getContentWithoutData(text).match(/(\s|^)#[a-zA-Z0-9_-]+/g);if(!matches){return[]}return matches.map(m=>m.trim())};const refreshUI=()=>{const codicentButtons=document.querySelectorAll("button[data-codicent-type]");codicentButtons.forEach(button=>{button.addEventListener("click",function(){const messageType=button.getAttribute("data-codicent-type");const message=button.getAttribute("data-codicent-message");if(messageType==="send"){window.Codicent.postMessage({message:message})}})});const counterElements=document.querySelectorAll('[data-codicent-type="counter"]');counterElements.forEach(element=>{const searchQuery=element.getAttribute("data-codicent-search");const skipContent=!!element.getAttribute("data-codicent-skip-content");let search={search:searchQuery,length:1e5,skipContent:skipContent};const afterTimestamp=element.getAttribute("data-codicent-after");if(afterTimestamp){search.afterTimestamp=new Date(afterTimestamp)}const beforeTimestamp=element.getAttribute("data-codicent-before");if(beforeTimestamp){search.beforeTimestamp=new Date(beforeTimestamp)}window.Codicent.getMessages(search).then(messages=>{const messageCount=messages.length;element.textContent=messageCount}).catch(console.error)})}}})(window);